# 操作系统的定义

1. 操作系统是最基本的系统软件，是一组有效管理和控制计算机硬件资源和软件资源/合理地对各类作业进行调度以阻止和控制系统作业的流程，并方便用户使用计算机的程序和集合。

2. MS DOS Windows UNIX Linux Novell Netware Vxworks AIX Android IOS FreeOS

# 计算机系统硬件组成

1. 内存系统
   
   * 主存
   
   * 高速缓存：缓解内存寻址访问效率较慢，而且考虑局部性原理而引入的。有硬件管理，对软件不可见。
   
   关联存储器及置换（淘汰）算法

2. 输入输出系统

IO设备 内存 CPU  DMA IO处理器

外设控制器：端口读写指令

指令集：用户指令集，系统指令集，系统调用（库函数）

# 用户指令集体系结构

1. 寄存器架构
   
   * 通用寄存器/特定类型寄存器（浮点数）
   
   * 专用寄存器（指针，链接，循环计数器）

2. 内存架构
   
   逻辑/虚拟地址空间：线性编址，分段编址（段号，段内偏移）

3. 用户指令:运算型
   
   内存存取指令/分支跳转指令

4. 内存管理模型
   
   * 实地址模型
   
   * 平坦模型/分段模型

# 系统指令集体系接结构及陷入机制

1. 特权级别和环结构
   
   * 用户模式，特权/超级/系统模式

2. 系统指令集体系结构
   
   * 系统寄存器架构：系统时钟，陷入与中断寄存器，陷入与中断屏蔽寄存器，页/段表指令寄存器
   
   * 处理器资源管理支持：系统调用/返回指令，中断定时器及设置机制
   
   * 内存资源管理支持：虚拟地址空间到物理地址空间的映射
   
   * I/O资源管理支持：I/O设备寻址与指令

3. 陷入与中断
   
   * 陷入：<font color = 'red'>指令</font>执行时因异常情况产生的控制迁移副效应。
   
   * 中断：由相对于当前执行进程的外部事件引起，与特定指令执行无关，如I/O操作，定时等。

# 操作系统硬件基础

1. IA-32体系
   
   中断描述符表
   
   外围设备：
   
   * 软盘控制器/硬盘控制器
   
   * 显卡
   
   * 中断控制器
   
   * DMA控制器
   
   * 串行控制器
   
   * BIOS

# 设备驱动程序装入操作系统的3个途径

1. 将内核与设备驱动程序重新链接，然后重启系统，很多UNIX系统以这种方式；

2. 在一个操作系统文件中设置一个入口，并通知该文件需要一个设备驱动程序，然后重启系统。在系统启动时，操作系统去找寻所需的设备驱动程序并装载，Windows是以这种方式工作；

3. 操作系统能够在运行时接受新的设备驱动程序并立即将其安装好，无需重启，热插拔设备，如USB，IEEE 1394都需要动态可装载设备驱动程序。

设备驱动程序的接入方式：

1. 设备寄存器被映射到操作系统的地址空间，设备可以像普通字设备一样读入读出，不需要专门的I/O指令。这个地址空间十操作系统的地址空间，用户在硬件上直接被隔离在外，防止其接触这些存储器地址。这种方式不需要专门的I/O指令，但是占用了一些地址空间。

2. 设备寄存器被放入一个专门的I/O端口空间中，每个寄存器都有一个端口地址，这些设备提供了在内核态可以使用的IN和OUT指令，供设备驱动程序读写这些寄存器。这种方式，不占用地址空间，但是需要专门 的指令。

设备输入输出的方式：

1. 忙等待，占据CPU，CPU一直轮询设备直到对应的I/O操作完成。

2. 中断，当设备驱动程序检测到该设备的操作完成时，发出一个中断通知。

3. 直接存储访问，为I/O提供DMA芯片，可以控制内存和某些控制器之间的位流，而无需CPU干预。CPU对DMA进行设置，说明需要传送的字节数，有关的设备和内存地址以及操作方向，接着启动DMA。当DMA完成时，触发一个中断。

# 操作系统用户接口

1. 基于接口表现形式划分
   
   * 用户交互接口：命令接口（<font color='red'>在线</font>，脱机（批处理/脚本）方式），图形化用户接口
   
   * 用户程序接口：方便用户程序访问系统资源，由一组<font color='red'>系统调用</font>组成

2. 基于接口使用者类型划分
   
   * 本地用户接口
   
   * 远程用户接口（网络用户接口http，ftp, telnet）

3. 操作系统联机命令接口
   
   联机命令接口组成：一组联机命令，键盘和显示终端处理程序，<font color='red'>命令解释程序</font>
   
   输入输出重定向，管道连接（不同命令间的数据传输，例 ps -A | grep ssh）

# 操作系统图形化用户接口

同屏多窗口与并发进程相对应

面向对象的程序设计方法

<font color= 'red'>消息</font>产生，传递及处理

<font color='red'>事件</font>驱动模式

# 系统调用概念及实现原理

系统与普通的过程调用的区别：

* 运行在不同的系统状态（用户态->内核态）

* 软中断进入机制

* 返回及重新调度问题

* 嵌套调用

系统调用的类型：

* 进程控制
  
  * 进程的创建，结束，等待子进程结束
  
  * 进程属性设置与获取
  
  * 执行一个文件（进程映像替换）

* 文件操作（涉及外设，存储器）
  
  * 文件的创建，打开，关闭，读写

* 进程通信
  
  * 连接与关闭，消息发送与接收

* 系统信息维护
  
  * 时间设置与获取，文件访问/修改时间设置
  
  系统调用的实现：
  
  * 使用库函数（封装了系统调用）
  
  * 使用系统调用（系统调用号）
  
  * 系统调用表->本质上利用函数指针数组实现。

* 混合编程要领
  
  * 汇编语言源程序调用C函数模块
    
    * 按逆向顺序把C函数模块压入栈中
    
    * call C函数模块
    
    * 清除先前压入栈中的C函数模块
  
  * C语言程序嵌入汇编指令
    
    * _asm_volatile()

* 系统调用的实现要领
  
  * 设置系统调用号和参数
    
    * 系统调用号：指定寄存器/内存单元
    
    * 参数：直接（寄存器），间接（参数表指针）
    
    * 方式：UNIX采用CHMK命令，DOS采用INT21软中断
  
  * 系统调用命令的一般性处理
    
    * 处理机状态由用户态切位系统态
    
    * 保护CPU现场，将PSW（程序状态字，Program Status Word），PC，系统调用号，用户栈指针，通用寄存器等压入堆栈
    
    * 用户定义参数送至指定位置
  
  * 分析系统调用类型，转相应处理子程序
    
    * 中断和陷入向量表（入口地址，PSW）

# BIOS程序

1. 概念
   
   BIOS是微机的基本输入输出系统，其内容集成在微机主板上的一个ROM芯片，主要保存着有关微机系统最重要的基本输入输出程序，系统信息设置，开机上电自检程序和系统启动自举程序。BIOS ROM芯片不但可以在主板上看到，而且BIOS管理功能如何，很大程度上决定了主板的性能。

2. BIOS的作用
   
   1. BIOS中断服务
      
      微机系统中软件与硬件之间的一个可编程接口，主要用来在程序软件与微机硬件之间实现衔接，对外围设备的管理都是建立在BIOS系统中断服务基础上的，操作人员也可以直接访问INT5，INT13等中断直接调用BIOS中断服务。
      
      BIOS中断服务为我们封装了许多系统底层的细节，其实操作员可以直接用输入输出程序对硬件端口进行操作，而不需要调用BIOS中断，但是调用BIOS中断可以让操作员不须对底层硬件端口过多了解有详细了解就能够编程。
      
      BIOS中断向量表只在实模式下使用，在保护模式下，会重新设置。
   
   2. BIOS系统设置程序
      
      微机部件配置记录时放在一块可读写的CMOS RAM芯片中的，主要保存着系统基本情况，CPU特性，软硬盘驱动器，显示器，键盘等部件信息，以及实时时钟信息，由纽扣电池供电。CMOS中记录的参数，是BIOS启动时候进行自检，以及硬件初始化和检测，启动扇区的搜索顺序等的依据。在BIOS ROM芯片中装有“系统设置程序”，主要用来设置CMOS RAM中的各项参数。这个程序在开机时按下莫格特定键即可进行设置状态，并提供良好的界面供操作人员使用，这个过程一般称为“BIOS设置”。
   
   3. POST上电自检
   
   4. BIOS系统启动自举程序
      
      系统在完成POST自检后，ROM BIOS就首先按照CMOS RAM中设置保存的启动顺序来搜寻软硬盘驱动器及CD-ROM,网络服务器以及有效的启动驱动器，读入操作系统引导程序，然后将系统控制权转移到引导程序，并由引导程序进行二次引导完成操作系统的加载。

3. BIOS执行的时序
   
   * 上电后，电压不稳定，主板上的控制芯片会向CPU发出并保持一个重置信号，让CPU内部自动恢复到初始状态，直到主板控制芯片检测到电源稳定时，会撤销重置信号，CPU便进入下一步；
   
   * 同时，硬件会将BIOS ROM中的BIOS程序加载到RAM中；
   
   * 上电开机后，CPU处于实模式，CPU会执行地址为0x0FFFF0处的指令，这条指令是一个跳转，跳到BIOS程序的真正入口地址，这个地址随着BIOS程序不同而不同；
   
   * 执行POST(加电自检，Power On Self Test)，检测设备是否正常，设备设置与CMOS中是否一致。异常则鸣喇叭；
   
   * 初始化显示设备并显示显卡信息，初始化其他设备；
   
   * 检查CPU和内存，并显示检测结果；
   
   * 检测标准设备，如硬盘，光驱，串口设备等；检测即插即用设备，并分配中断号，I/O端口和DMA资源；<mark>建立中断向量表和中断服务程序</mark>。
   
   * 如果上面的硬件设备发生变化，则更新到CMOS中；
   
   * 将启动设备主引导记录的启动代码通过BIOS中断读入内存，开始引导程序执行；
   
   * 第二次引导，进入到操作系统。

4. 参考资料
   
   * 《完全BIOS手册》
   
   * 《自己手写操作系统》第1章。
   
   * 《一个操作系统的实现》——《自己手写操作系统Ed2》第一章。
   
   * 《Linux内核设计的艺术：图解Linux操作系统架构设计与实现原理》
   
   * 《Linux内核完全剖析：基于0.12内核》第6章。
   
   * 《UEFI原理与编程》1.1节。
   
   * 《鸟哥的Linux私房菜基础篇》第20章。
   
   * 《深入理解Linux内核》附录1。
   
   * 《操作系统真相还原》第2章。
   
   * 网络链接：<https://www.2cto.com/os/201603/494064.html>

5. 中断向量表
   
   中断向量：中断处理程序的入口。
   
   中断向量表：中断处理程序的入口列表。
   
   中断向量是将256个中断向量，按中断类型从小到大的顺序存放到内存的某一区域。中断向量表只在实模式才有意义。
   
   来源：实模式下，中断向量表是复位启动时由BIOS负责设置写入。
   
   在保护模式下，中断向量在检索对应中断程序的起始地址，用的是中断描述符表。

6. 实模式与保护模式
   
   * 实模式
     
     在计算机上，实模式存在的时间非常短，一般感受不到。CPU复位或加电的时候是以实模式运行的，不能实现权限分级，不能访问20位以上地址线（1MB内存），加载操作系统之后，就进入保护模式了。
     
     实模式下：物理内存地址 = 段地址*16 + 偏移地址
   
   * 保护模式
     
     由于实模式下，是将整个物理内存看成分段的区域，即程序代码和数据位于不同区，而系统程序和用户程序没有区别对待。每一个指针都是指向实地址的，容易出现用户程序指针指向系统程序区域或者系统程序指针指到了用户程序区域，容易导致系统程序或用户程序被修改，容易造成系统崩溃。为了保护进程空间，就产生了保护模式，势必会产生一种新的寻址方式。
     
     保护模式虽然也采用了段和偏移的概念，但是保护模式下，段仅仅作为一个索引，这个索引指向一个数据结构的一个表项，表项中详细定义了段的起始地址，界限，属性等内容。这个数据结构是全局描述符GDT。保护模式下，32位环境下用一个段就可以访问4GB内存。
     
     保护模式的目的是，对硬件系统进行严格地管理，使得硬件系统对用户来说是屏蔽的，用户只能看到操作系统，但不能直接接触到硬件系统，硬件系统都被操作系统管理着。保护模式下，想用汇编语言真实地操作硬件系统是完全不可能的。
   
7. 实模式1MB地址线布局

   1. 0~0x9FFFF是映射DRAM，主要是MBR和中断向量表；
   2. 0x9FFFF~0xEFFFF是映射外设，包括显存，键盘鼠标内存等；
   3. 0xEFFFF~0xFFFFF是映射存储BIOS程序的ROM。
   
8. specific process of startup

   1. 当我们按下电源键时，电源开始给主板和其他外设供电，此时电压还不稳定，主板上的控制芯片组会向CPU发出并保持一个reset信号，让CPU内部自动恢复到初始状态，而不是立马就开始运转，使CPU此刻不会立马按照cs:ip执行指令，电压不稳定情况下运转会发生意想不到的问题。
   2. 当芯片组检测到电源已经开始稳定供电后，它便撤去reset信号（如果使手动按下面板上的reset键来强制重启机器，则在手松开时芯片组就会车去reset信号）。CPU马上按照cs:ip（0xFFFF0，即CS=0xFFFF, IP=0x0000，暂且理解为CPU特性）处开始执行命令，这条指令是一条跳转指令，跳到BIOS ROM内存中真正的启动代码处。
   3. 开始执行BIOS代码。进行加电后自检POST(power-on self-test)，检测系统中一些关键设备是否存在和是否能正常工作，例如显卡和内存。POST是最先进行的，此时还没有初始化显存，因此自检有问题，不能通过显示器展示，只能通过蜂鸣器发声来报告错误，声音的长短和次数代表错误的类型。POST在检查内存时只会检查640k的DRAM内存。正常情况下，POST过程非常快，几乎感受不到它的存在。
   4. POST结束后，BIOS代码开始进行更完整的硬件检测（**需要注意，BIOS不只时存在主板ROM上的一个，每个外设几乎都有一个BIOS，用于CPU对本外设的自检和初始化**）。查找显卡BIOS，通常地址为0xC0000处，查找到显卡BIOS后，调用它的初始化代码，此时能在显示器上显示一些初始化信息，例如生产厂家/图像芯片类型等信息。接着继续查找其他设备的BIOS，找到后同样调用该设备的BIOS程序，进行初始化。
   5. 查找完其他设备的BIOS后，系统BIOS会显示它的启动画面，包括所有系统BIOS的类型，序列号和版本号等内容。
   6. 系统BIOS检测CPU的类型和工作频率，然后测试所有的RAM，并在屏幕显示内存测试的进度，这个可以在COMS中进行设置，时简单耗时少的还是详细耗时多的测试方式。
   7. 内存测试通过后，系统BIOS开始检测安装的一些标准硬件，包括硬盘，cd-rom，串口，并口，软驱等设备，以及定时设置，硬盘参数和访问模式等。
   8. 标准设备检测完毕后，系统BIOS内部的支持热插拔代码开始检测和配置安装的热插拔设备，每找到一个设备，系统BIOS都会在屏幕中显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I/O端口等资源。
   8. 建立中断向量表等工作。
   9. 引导MBR到内存，开始引导操作系统运行。

# 操作系统引导过程及引导程序

1 DOS系统结构

* 引导扇区与系统启动
  
  * 系统启动过程
    
    * 机器上电
    
    * BIOS加电自检进行硬件检测，BIOS使用统一地址空间，占用的起始地址为0FFFF：0000
    
    * 读入启动盘引导扇区（0号磁头，0号柱面，1号扇区）512字节到内存0000：7C00处
    
    * 检查内存0000：7DFE~7DFF是否为0x55AA
    
    * 跳转至0000：7C00执行引导记录程序
  
  * 引导扇区
    
    * 末2个字节为0xAA55
  
  * 引导程序编制基础
    
    * 开发工具NASM或GCC
    
    * 引导代码必须编译成平坦型二进制类型，且大小为512B

* 关于引导程序为什么要指定程序起始地址
  
  * ORG指令
    
    ORG是Origin的缩写，起始地址的含义。在汇编语言源程序开始的地方通常用一条ORG伪指令来实现规定程序的其实地址。如果不加ORG规定，则汇编得到的目标程序从0000H开始，即代码被放到内存空间的CS：0处。若由ORG，则编译器会将其后的指令代码放到**ORG伪指令指定的<mark>偏移地址</mark>**。ORG是伪指令，是链接时使用。
  
  * <mark>问题：</mark>既然BIOS会把引导盘的0磁道，0磁头，1扇区的代码读到绝对地址0x7C00处，并从此处开始执行，那么为什么引导程序还要ORG 0x7C00呢？
    
     **解答：** BIOS将代码加载到了内存的0x7C00处后开始执行，如果代码中定义了一个数据，而代码中都是用的偏移地址定义的。需要读取时，因为此时的段地址为0x0000，偏移地址的起始也为0x0000，而实际地址为0x0000+0x7c00+偏移地址，所以与预期不一致。在开头加上ORG 0x7C00后，会将偏移地址从0x7C00开始。

2 汇编伪指令

  汇编伪指令和汇编语言相同，与CPU架构相关。不同的CPU架构，例如X86和ARM，是不同的。汇编程序除了指令语句，还需要提供一些指令，用于辅助源程序的汇编。比如指定源程序或数据存放的起始地址，为数据分配一段来连续的内存单元等，这些指令在汇编时不产生目标代码，不影响程序的执行。

  部分伪指令总结如下：

* EQU ：将操作数赋予标号，类似与C语言的#define。

* ORG：设置此后的第一条语句的本段的偏移地址起始值，直到下一条ORG指令。

* DB：字节数据，把字节常数或字符串存放在内存连续的地址空间。

* END：表示汇编语言程序段结束。源程序只能由一个END。

3 Bochs模拟器

bochs是一个x86硬件平台模拟器，可以模拟各种硬件的配置，包括I/o，内存和BIOS。

# 操作系统二次加载引导过程

一次引导由BIOS实现，二次引导由一次引导实现。二次引导实现内核代码的加载。

# 操作系统的发展动力和技术基础

发展动力：

* 计算机资源利用率和系统性能提高的需要

* 改善和方便用户使用计算机的需求

* 适应器件不断更新换代

* 适应计算机体系结构不断发展

矛盾：

* 人机矛盾：人工操作与CPU计算速度的矛盾

* CPU与I/O设备间矛盾：CPU速度迅速提高而I/O设备速度提高缓慢

缓和途径：

* 通道技术，中断技术，缓冲技术

* 脱机输入输出技术

* 专门的操作人员及批处理技术

单道批处理程序的特点：

* 自动行：磁带上的一批作业能自动地逐个依次执行，而无需人工干预

* 顺序性：磁带上地各道作业时顺序地进入内存，完成顺序与进入内存地顺序完全一致

* 单道性：监控程序每次仅有一道程序，仅当该程序完成或发生异常才调入下一道程序进入内存。

多道批处理系统地特点：

* 多道性：内存中同时驻留多道程序，并允许并发执行

* 无序性：多个作业完成地先后次序与它们进入内存地顺序之间，并无严格地对应关系

* 调度性：
  
  * 作业调度：外存到内存
  
  * 进程调度：内存到处理器

# 操作系统的分支

分时系统

分时系统概念：一台主机、多个终端、多用户同时以交互方式使用计算机

分时系统实现中的关键问题：

* 及时接收用户输入命令和数据：配置多路卡及设置多路缓冲区
* 及时处理
  * 使所有用户作业都直接进入内存，而不再是磁盘，与处理器速度匹配
  * 在不长的时间内就能使作业都运行一次，时间片轮转策略

分时系统的特征：

* 多路性：宏观上多个用户同时作业和共享系统资源；微观上每个用户作业轮转运行一个时间片。
* 独立性：各用户在各自终端上独立操作，互不干扰。
* 及时性：响应时间
* 交互性：用户可通过终端与系统进行广泛的人机对话，不再是批处理方式。

实时系统

实时系统的概念：系统能及时或即时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。

实时任务的类型：

* 按任务执行是否程序爱你周期性来划分
* 根据对截止时间的要求来划分

# 操作系统处理器管理功能概要

处理器调度

作业调度

* 作业后备队列
* 作业选择与资源分配
* 调入内存与建立进程

进程调度

* 就绪进程队列
* 进程选择与处理机分配
* 设置运行现场与启动运行

调度算法

* 先来先服务算法
* 优先权高者优先调度算法

进程控制

主要任务：创建进程，撤销进程，进程状态切换

进程控制机制：原语，进程与线程

进程同步

主要任务：进程/线程并发执行协调，互斥/同步方式，临界资源与临界区

进程同步机制：

* 开/关锁原语
* 信号量机制
* 管程

进程通信

主要任务：进程（或线程）间信息交换

进程通信方式：

* 共享内存方式

* 管道方式

* 消息传递系统
  
  * 消息缓冲队列
  
  * 邮箱

# 操作系统内存管理功能概要

内存分配

主要功能：

* 使程序各得其所

* 提高存储器利用率

* 适应程序和数据动态增长地需要

内存分配机制：

* 内存分配用数据结构

* 内存分配采用连续/离散分配方式

* 内存分配采用静态/动态分配方式

* 内存回收

内存保护

主要功能：

* 确保内核安全及程序间互不干扰

* 存取访问机制

内存保护机制：

* 越界检查

* 硬件实现

* 保护方式
  
  * 上下限界限寄存器
  
  * 页号小于页表长度
  
  * 段号小于段号长度，且，段内地址小于段长
  
  * 特权级比较

地址映射

主要任务：逻辑地址转换为物理地址

基本概念：

* 地址空间&内存空间

* 逻辑/相对/有效地址

* 物理/绝对地址

地址映射机制

* 硬件实现

* 重定位寄存器，页表/段表，快表

内存扩充

主要任务：从逻辑上扩充内存容量

内存扩充可行性

* 程序运行局部性原理，时间局部性，空间局部性

* 离散分配方式

内存扩充机制：

* 虚拟存储技术

* 硬件（页/段表，缺页/段中断，地址变换）

* 软件（请求调入功能/置换功能）

# 操作系统的设备管理功能概要

设备分配

主要任务：设备及相应设备控制器和通道的分配

设备分配机制：

* 设备分配用数据结构

* 设备类型与设备分配方式相对应

* 设备分配与回收算法

* **设备独立性**

* **虚拟设备** 

缓冲管理

主要任务：

* 管理各种类型的缓冲区（属于内存）

* 缓和CPU和I/O设备速度不匹配矛盾

* 提高资源利用率和系统吞吐量

缓冲管理机制：

* 单/双/多缓冲类型

* 字符缓冲与盘块缓冲

* 公用缓冲池机制

设备驱动程序

主要任务：实现CPU和设备控制器间的通信

设备处理过程：

1. I/O请求提出

2. 驱动程序对I/O请求合法性检查

3. 了解设备状态

4. 传递相关参数并设置设备工作方式

5. 通道程序自动构成

6. 发出I/O指令和启动I/O设备

7. 及时响应中断请求

# 操作系统的文件管理功能概要

文件存储空间管理

主要任务：

* 使每个文件各得其所
* 提高外存空间利用率
* 提高外存访问速度

文件存储空间管理机制：

* 存储空间管理用数据结构
* 存储空间分配与回收功能
* 连续/离散分配方式
* 以盘块/簇为基本分配单位

目录管理

主要任务：

* 实现文件的按名存取
* 提高文件查找速度
* 支持文件重名、共享与保护

目录管理机制：

* 文件控制块与索引节点
* 目录结构
* 目录检索手段

文件的读写管理与存取控制

文件的读写管理

* 从外存中读取数据或间数据写入外存
* 目录检索 -> 外存地址 -> 读写指针 -> 读写操作
* 文件描述符表和文件表

文件的存取控制

* 防止未经核准的用户存取文件
* 防止冒名顶替存取文件
* 防止以不正确的方式使用文件
* 系统及/用户级/文件级存取控制

# 操作系统的特征

并发：并行与并发、程序与进程/线程

共享：互斥共享方式、同时访问方式

虚拟：虚拟处理及、虚拟内存、虚拟盘、虚拟设备

异步：进程执行顺序与执行时间的不确定性

# 操作系统的设计原则

* 可维护性
* 可靠性
* 可理解性
* 可用性
* 性能

# 操作系统结构化设计问题

操作系统非结构化设计问题（整体式操作系统结构）

早期设计的操作系统时没有结构化思维的，典型的是DOS。现代操作系统已经没这种问题。

* 致力于功能实现和提高效率
* 缺乏首尾一致的设计思想
* 过程集合内各过程间可相互调用
* 操作系统内部不存在任何结构
* GOTO语句不加限制
* 系统易出错、调试困难、维护麻烦

模块化及分层式操作系统结构

举例：

> 操作系统
>
> 1. 进程管理
>    * 进程调度
>    * 进程控制
>    * 进程同步
>    * 进程通信
> 2. 内存管理
> 3. 文件管理
> 4. 设备管理

操作系统模块化的优点

* 提高了设计的正确性、可理解性和可维护性
* 增强了操作系统的可适应性
* 加速了操作系统的开发过程

操作系统模块化的改进空间：

* 模块划分和接口规定难保正确和合理
* 未能区别共享资源和独占资源
* 管理差异导致模块间依赖关系复杂

分层原则：

分层较低的，对硬件依赖度高，移植工作大

* 被调用功能放在较低层次

  作业调度->进程控制->内存管理

* 活跃功能放在低层

  时钟管理、进程调度

* 资源分配策略放在高层

  便于修改或适应不用环境

* 最低层

  资源管理公用模块如队列、堆栈、信号量操作等

* 最高层

  用户接口

# 微内核操作系统结构

机制与策略分离、客户/服务器模式

1. 内核仅实现硬件相关及最基本功能：进程调度与控制、进程同步与通信、地址转换机制、中断/陷入处理、设备驱动
2. 其余更多系统功能放在内核之外：用户进程分类及优先级算法、页面淘汰算法、分配策略

结构评估：

1. 可扩充性、正确性、可靠性较高
2. 便于网络服务和实现分布式处理
3. 系统效率受到影响

# 程序的顺序执行与并发执行

程序顺序执行时的特征：

* 程序独占全机资源
* 只有当前运行程序才能改变资源状态
* 程序执行结果不受外界因素影响
* 只要程序执行时的环境和初始条件相同，程序重复执行结果系统
* 因可再现，调试简单

程序并发执行时的特征

* 间断性：执行->暂停执行->执行的规律

* 失去封闭性

  系统资源共享及资源状态改变的多样性，致使程序运行失去封闭性，程序运行必然会受到其他程序的影响

* 不可再现性

  并发执行的程序，计算结果与其执行推进速度及时间有关。引入了进程概念，解决了此问题。

# 虚拟地址空间

Linux进程虚拟地址空间是Linux内存管理地一个重要部分，对32位系统地址空间范围为4G，,总地地址空间通常按照3：1比例划分，用户态3G，内核态1G。

各进程地用户态虚拟地址空间起始于地址0，延伸到TASK_SIZE-1的位置，其上是内核地址空间。无论当前的哪个用户进程处于运行状态，虚拟地址空间的内核部分总是相同的。

# 进程同步机制

**进程同步机制的基本准则**：

1. 空闲让进

   当无进程处于临界区时，可允许一个请求进入临界区的进程立即进入自己的临界区。

2. 忙则等待

   当已有进程进入自己的临界区时，所有企图进入临界区的进程必须等待。

3. 有限等待

   对要求访问临界资源的进程，应保证该进程能在有限时间内进入自己的临界区。

4. 让权等待

   当进程不能进入自己的临界区时，应释放处理器。

**进程互斥访问临界资源的软件解决方案**

1. 设置访问编号，全局整型变量

   进程进入临界区之前判断访问编号是否符合要求，如果满足则访问临界资源，不满足则不操作。在访问完临界资源后，应将访问权交付别的进程(修改访问编号)。

   缺陷：但是这种方案，在未获得临界资源时，进程未释放处理器，仍在执行空操作，不满足让权等待的原则。另外，临界资源访问权的强制交付是不科学的，违背了空闲让进原则。

2. 设置访问标志，每个进程一个访问标志，全局整型变量

   进程进入临界区之前判断别的进程是否正在访问临界资源。
   
   缺点：不能满足让权等待原则，也违背了忙则等待的原则。
   
3. 设置预访问标志，每个进程一个预访问标志，全局整型变量

   先设置本进程预访问标志，再判断其他进程是否在访问临界资源。但是如果判断出来别的进程的预访问标志为true，则空等待。

   缺点：不能满足让权等待的原则，可能存在陷入僵局的问题，违背了有限等待的原则。

4. Peterson算法，编号+标志

   每个进程一个标志，同时增加一个编号（标识正在访问临界资源的进程号）

   * 假如两个进程都有意愿进入临界资源，flagi、flagj均为true，当编号turn取值是确定的，肯定会有一个进程进入临界区，所以空闲让进；
   * 一个进程进入临界区，说明另一个进程或者无意愿进入即flag为false，或者来晚一步。

**进程互斥访问临界资源的硬件解决方案**

完全利用软件方法解决诸进程互斥进入临界区的问题，有一定难度，且有很大的局限性，因而现在已经很少采用此方法。相应地，现在许多计算机提供了一些特殊地硬件指令，有关指令允许对一个字中地内容同时进行检测和修正（或交换）两个字地内容，故而可以用于解决临界区问题。硬件指令都是原子操作，所以能够很好地解决临界资源地互斥问题，简化了问题。但是都不可避免不能实现让权等待原则的问题。

Test-and-Set指令，Swap指令

**信号量**

信号量的定义：信号量是操作系统用来解决并发中的互斥和同步问题的一种方法。信号量是一个与队列有关的整型变量，可以想象成一个数后面拖着一个队列。信号量n代表可用临界资源，而队列是用来存放正在排队等待使用这一临界资源的进程。信号量的数值n大于0表示可用资源数，小于0表示阻塞等待的进程数。信号量的优势时可以实现让权等待，即无忙等待。

使用场景，通常用于那些资源有明确访问数量吸纳之的场景，常用于限流。例如，数据库连接池，同时进行连接的线程数量有限制，连接不能超过一定数量，当连接达到了限制数量后，后面的线程只能排队等待前面的线程释放了数据库连接才能获得数据库的连接。

进程的互斥：当多个进程由共同的临界区时，进入临界区的进程只能由一个。

进程的同步：由逻辑关联的进程先后执行，例如B进程只有等待A进程执行完才能执行，A没执行完B进程只能挂起。实际上，这是一种约束，也是一种通信。需要同步的进程不一定有共同的临界区。

信号量的伪代码：

```
struct semaphore{
	int count;
	queueType queue;    //阻塞队列
}
void semWait(sempaphore s)    //申请资源
{
	s.count--;
	if(s.count < 0){
		/*place this process in s.queue */
		/*block this process*/
	}
	else
	{
		/*run*/
	}
}
void semSignal(semphore s)   //释放资源
{
	s.count++;
	if(s.count <= 0){     //说明此时还有进程在排队，例如进程P
		/* remove a process P from s.queue*/
		/*place process P on ready list*/
	}
}
```

1. 禁用硬件中断和基于硬件的原子操作，单纯实现了进程对临界资源的互斥；
2. 基于软件的算法（例如Peterson算法、面包店算法）既实现了互斥，又实现了同步；
3. 信号量可以但不一定实现互斥，但一定实现了同步。



