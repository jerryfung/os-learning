# 操作系统的定义

1. 操作系统是最基本的系统软件，是一组有效管理和控制计算机硬件资源和软件资源/合理地对各类作业进行调度以阻止和控制系统作业的流程，并方便用户使用计算机的程序和集合。

2. MS DOS Windows UNIX Linux Novell Netware Vxworks AIX Android IOS FreeOS

# 计算机系统硬件组成

1. 内存系统
   
   * 主存
   
   * 高速缓存：缓解内存寻址访问效率较慢，而且考虑局部性原理而引入的。有硬件管理，对软件不可见。
   
   关联存储器及置换（淘汰）算法

2. 输入输出系统

IO设备 内存 CPU  DMA IO处理器

外设控制器：端口读写指令

指令集：用户指令集，系统指令集，系统调用（库函数）

# 用户指令集体系结构

1. 寄存器架构
   
   * 通用寄存器/特定类型寄存器（浮点数）
   
   * 专用寄存器（指针，链接，循环计数器）

2. 内存架构
   
   逻辑/虚拟地址空间：线性编址，分段编址（段号，段内偏移）

3. 用户指令:运算型
   
   内存存取指令/分支跳转指令

4. 内存管理模型
   
   * 实地址模型
   
   * 平坦模型/分段模型

# 系统指令集体系接结构及陷入机制

1. 特权级别和环结构
   
   * 用户模式，特权/超级/系统模式

2. 系统指令集体系结构
   
   * 系统寄存器架构：系统时钟，陷入与中断寄存器，陷入与中断屏蔽寄存器，页/段表指令寄存器
   
   * 处理器资源管理支持：系统调用/返回指令，中断定时器及设置机制
   
   * 内存资源管理支持：虚拟地址空间到物理地址空间的映射
   
   * I/O资源管理支持：I/O设备寻址与指令

3. 陷入与中断
   
   * 陷入：<font color = 'red'>指令</font>执行时因异常情况产生的控制迁移副效应。
   
   * 中断：由相对于当前执行进程的外部事件引起，与特定指令执行无关，如I/O操作，定时等。

# 操作系统硬件基础

1. IA-32体系
   
   中断描述符表
   
   外围设备：
   
   * 软盘控制器/硬盘控制器
   
   * 显卡
   
   * 中断控制器
   
   * DMA控制器
   
   * 串行控制器
   
   * BIOS

# 设备驱动程序装入操作系统的3个途径

1. 将内核与设备驱动程序重新链接，然后重启系统，很多UNIX系统以这种方式；

2. 在一个操作系统文件中设置一个入口，并通知该文件需要一个设备驱动程序，然后重启系统。在系统启动时，操作系统去找寻所需的设备驱动程序并装载，Windows是以这种方式工作；

3. 操作系统能够在运行时接受新的设备驱动程序并立即将其安装好，无需重启，热插拔设备，如USB，IEEE 1394都需要动态可装载设备驱动程序。

设备驱动程序的接入方式：

1. 设备寄存器被映射到操作系统的地址空间，设备可以像普通字设备一样读入读出，不需要专门的I/O指令。这个地址空间十操作系统的地址空间，用户在硬件上直接被隔离在外，防止其接触这些存储器地址。这种方式不需要专门的I/O指令，但是占用了一些地址空间。

2. 设备寄存器被放入一个专门的I/O端口空间中，每个寄存器都有一个端口地址，这些设备提供了在内核态可以使用的IN和OUT指令，供设备驱动程序读写这些寄存器。这种方式，不占用地址空间，但是需要专门 的指令。

设备输入输出的方式：

1. 忙等待，占据CPU，CPU一直轮询设备直到对应的I/O操作完成。

2. 中断，当设备驱动程序检测到该设备的操作完成时，发出一个中断通知。

3. 直接存储访问，为I/O提供DMA芯片，可以控制内存和某些控制器之间的位流，而无需CPU干预。CPU对DMA进行设置，说明需要传送的字节数，有关的设备和内存地址以及操作方向，接着启动DMA。当DMA完成时，触发一个中断。

# 操作系统用户接口

1. 基于接口表现形式划分
   
   * 用户交互接口：命令接口（<font color='red'>在线</font>，脱机（批处理/脚本）方式），图形化用户接口
   
   * 用户程序接口：方便用户程序访问系统资源，由一组<font color='red'>系统调用</font>组成

2. 基于接口使用者类型划分
   
   * 本地用户接口
   
   * 远程用户接口（网络用户接口http，ftp, telnet）

3. 操作系统联机命令接口
   
   联机命令接口组成：一组联机命令，键盘和显示终端处理程序，<font color='red'>命令解释程序</font>
   
   输入输出重定向，管道连接（不同命令间的数据传输，例 ps -A | grep ssh）

# 操作系统图形化用户接口

同屏多窗口与并发进程相对应

面向对象的程序设计方法

<font color= 'red'>消息</font>产生，传递及处理

<font color='red'>事件</font>驱动模式

# 系统调用概念及实现原理

系统与普通的过程调用的区别：

* 运行在不同的系统状态（用户态->内核态）

* 软中断进入机制

* 返回及重新调度问题

* 嵌套调用

系统调用的类型：

* 进程控制
  
  * 进程的创建，结束，等待子进程结束
  
  * 进程属性设置与获取
  
  * 执行一个文件（进程映像替换）

* 文件操作（涉及外设，存储器）
  
  * 文件的创建，打开，关闭，读写

* 进程通信
  
  * 连接与关闭，消息发送与接收

* 系统信息维护
  
  * 时间设置与获取，文件访问/修改时间设置
  
  系统调用的实现：
  
  * 使用库函数（封装了系统调用）
  
  * 使用系统调用（系统调用号）
  
  * 系统调用表->本质上利用函数指针数组实现。

* 混合编程要领
  
  * 汇编语言源程序调用C函数模块
    
    * 按逆向顺序把C函数模块压入栈中
    
    * call C函数模块
    
    * 清除先前压入栈中的C函数模块
  
  * C语言程序嵌入汇编指令
    
    * _asm_volatile()

* 系统调用的实现要领
  
  * 设置系统调用号和参数
    
    * 系统调用号：指定寄存器/内存单元
    
    * 参数：直接（寄存器），间接（参数表指针）
    
    * 方式：UNIX采用CHMK命令，DOS采用INT21软中断
  
  * 系统调用命令的一般性处理
    
    * 处理机状态由用户态切位系统态
    
    * 保护CPU现场，将PSW（程序状态字，Program Status Word），PC，系统调用号，用户栈指针，通用寄存器等压入堆栈
    
    * 用户定义参数送至指定位置
  
  * 分析系统调用类型，转相应处理子程序
    
    * 中断和陷入向量表（入口地址，PSW）

# BIOS程序

1. 概念
   
   BIOS是微机的基本输入输出系统，其内容集成在微机主板上的一个ROM芯片，主要保存着有关微机系统最重要的基本输入输出程序，系统信息设置，开机上电自检程序和系统启动自举程序。BIOS ROM芯片不但可以在主板上看到，而且BIOS管理功能如何，很大程度上决定了主板的性能。

2. BIOS的作用
   
   1. BIOS中断服务
      
      微机系统中软件与硬件之间的一个可编程接口，主要用来在程序软件与微机硬件之间实现衔接，对外围设备的管理都是建立在BIOS系统中断服务基础上的，操作人员也可以直接访问INT5，INT13等中断直接调用BIOS中断服务。
      
      BIOS中断服务为我们封装了许多系统底层的细节，其实操作员可以直接用输入输出程序对硬件端口进行操作，而不需要调用BIOS中断，但是调用BIOS中断可以让操作员不须对底层硬件端口过多了解有详细了解就能够编程。
   
   2. BIOS系统设置程序
      
      微机部件配置记录时放在一块可读写的CMOS RAM芯片中的，主要保存着系统基本情况，CPU特性，软硬盘驱动器，显示器，键盘等部件信息，以及实时时钟信息，由纽扣电池供电。CMOS中记录的参数，是BIOS启动时候进行自检，以及硬件初始化和检测，启动扇区的搜索顺序等的依据。在BIOS ROM芯片中装有“系统设置程序”，主要用来设置CMOS RAM中的各项参数。这个程序在开机时按下莫格特定键即可进行设置状态，并提供良好的界面供操作人员使用，这个过程一般称为“BIOS设置”。
   
   3. POST上电自检
   
   4. BIOS系统启动自举程序
      
      系统在完成POST自检后，ROM BIOS就首先按照CMOS RAM中设置保存的启动顺序来搜寻软硬盘驱动器及CD-ROM,网络服务器以及有效的启动驱动器，读入操作系统引导程序，然后将系统控制权转移到引导程序，并由引导程序进行二次引导完成操作系统的加载。

3. BIOS执行的时序
   
   * 上电后，电压不稳定，主板上的控制芯片会向CPU发出并保持一个重置信号，让CPU内部自动恢复到初始状态，直到主板控制芯片检测到电源稳定时，会撤销重置信号，CPU便进入下一步；
   
   * 同时，硬件会将BIOS ROM中的BIOS程序加载到RAM中；
   
   * 上电开机后，CPU处于实模式，CPU会执行地址为0x0FFFF0处的指令，这条指令是一个跳转，跳到BIOS程序的真正入口地址，这个地址随着BIOS程序不同而不同；
   
   * 执行POST(加电自检，Power On Self Test)，检测设备是否正常，设备设置与CMOS中是否一致。异常则鸣喇叭；
   
   * 初始化显示设备并显示显卡信息，初始化其他设备；
   
   * 检查CPU和内存，并显示检测结果；
   
   * 检测标准设备，如硬盘，光驱，串口设备等；检测即插即用设备，并分配中断号，I/O端口和DMA资源；
   
   * 如果上面的硬件设备发生变化，则更新到CMOS中；
   
   * 将启动设备主引导记录的启动代码通过BIOS中断读入内存，开始引导程序执行；
   
   * 第二次引导，进入到操作系统。

4. 参考资料
   
   * 《完全BIOS手册》
   
   * 《自己手写操作系统》第1章。
   
   * 《一个操作系统的实现》——《自己手写操作系统Ed2》第一章。
   
   * 《Linux内核设计的艺术：图解Linux操作系统架构设计与实现原理》
   
   * 《Linux内核完全剖析：基于0.12内核》第6章。
   
   * 《UEFI原理与编程》1.1节。
   
   * 《鸟哥的Linux私房菜基础篇》第20章。
   
   * 《深入理解Linux内核》

# 操作系统引导过程及引导程序

## 1 DOS系统结构

* 引导扇区与系统启动
  
  * 系统启动过程
    
    * 机器上电
    
    * BIOS加电自检进行硬件检测，BIOS使用统一地址空间，占用的起始地址为0FFFF：0000
    
    * 读入启动盘引导扇区（0号磁头，0号柱面，1号扇区）512字节到内存0000：7C00处
    
    * 检查内存0000：7DFE~7DFF是否为0x55AA
    
    * 跳转至0000：7C00执行引导记录程序
  
  * 引导扇区
    
    * 末2个字节为0xAA55
  
  * 引导程序编制基础
    
    * 开发工具NASM或GCC
    
    * 引导代码必须编译成平坦型二进制类型，且大小为512B

* 关于引导程序为什么要指定程序起始地址
  
  * ORG指令
    
    ORG是Origin的缩写，起始地址的含义。在汇编语言源程序开始的地方通常用一条ORG伪指令来实现规定程序的其实地址。如果不加ORG规定，则汇编得到的目标程序从0000H开始，即代码被放到内存空间的CS：0处。若由ORG，则编译器会将其后的指令代码放到**ORG伪指令指定的<mark>偏移地址</mark>**。ORG是伪指令，是链接时使用。
  
  * <mark>问题：</mark>既然BIOS会把引导盘的0磁道，0磁头，1扇区的代码读到绝对地址0x7C00处，并从此处开始执行，那么为什么引导程序还要ORG 0x7C00呢？
    
     **解答：** BIOS将代码加载到了内存的0x7C00处后开始执行，如果代码中定义了一个数据，而代码中都是用的偏移地址定义的。需要读取时，因为此时的段地址为0x0000，偏移地址的起始也为0x0000，而实际地址为0x0000+0x7c00+偏移地址，所以与预期不一致。在开头加上ORG 0x7C00后，会将偏移地址从0x7C00开始。

## 2 汇编伪指令

  汇编伪指令和汇编语言相同，与CPU架构相关。不同的CPU架构，例如X86和ARM，是不同的。汇编程序除了指令语句，还需要提供一些指令，用于辅助源程序的汇编。比如指定源程序或数据存放的起始地址，为数据分配一段来连续的内存单元等，这些指令在汇编时不产生目标代码，不影响程序的执行。

  部分伪指令总结如下：

* EQU ：将操作数赋予标号，类似与C语言的#define。

* ORG：设置此后的第一条语句的本段的偏移地址起始值，直到下一条ORG指令。

* DB：字节数据，把字节常数或字符串存放在内存连续的地址空间。

* END：表示汇编语言程序段结束。源程序只能由一个END。

# 操作系统二次加载引导过程
