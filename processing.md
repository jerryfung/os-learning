<!--本文本主要介绍进程相关-->

# 引入进程的原因

1. 《现代操作系统》2.1节的说法：伪并行的存在使人们很难对多个并行的活动进行跟踪，因此设计出了描述并行的一种概念模型，使得并行更容易处理。
2. 《Orange's 一个操作系统的实现》6.2.2节的说法：需要一个数据结构记录一个进程的状态，在进程要被挂起的时候，进程信息就被写入这个数据结构，等到进程重新启动的时候，这个信息重新被读出来。
3. 《操作系统设计与实现》2.1.1节的说法：考虑在伪并行情况下运行的进程集，要比试图跟踪CPU如何在程序间来回切换简单的多，这种快速切换称为多道程序，每个进程拥有自己的虚拟CPU。
4. 《操作系统原理及应用》2.1.2节的说法：由于程序执行的顺序性、间断性、不可再现性，用程序作为描述其执行过程和共享资源的基本单元，既增加了操作系统设计和实现的复杂性，又无法反映操作系统应具有的程序段执行的并发性、用户随机性，以及资源共享等特性。也就是说，用程序作为描述其执行过程以及共享资源的基本单元是不合适的。就需要一个既能描述程序的执行过程，又能用来共享资源的基本单元。
5. 《操作系统真相还原》9.1.2节的说法：任何代码块都可以独立，只要在它运行的时候，给他准备好它所依赖的上下文环境就行，这个上下文环境就是它所使用的寄存器映像和栈等资源。只要是独立的执行流就可以被调度器视为一个调度单元，就可以享受处理器的单独服务。因此，只要给这个代码块准备好它所依赖的上下文环境，从而使其具备独立性，就可以成为执行流，即调度单元。调度单元，可以是进程，也可以是线程。
6. 《深入理解Linux内核》第3章的说法：从内核观点看，进程的目的就是担当分配系统资源(CPU、内存等)的实体。
7. bilibili 北交大操作系统课程P31的说法：基于程序的概念已不能完整、有效地描述并发程序在内存中的运行状态。必须建立并发程序的新的描述和控制机制。使用程序段、数据段和进程控制块来引入进程的概念。进程控制块存放了进程标识符、进程运行的当前状态、程序和数据的地址以及关于该程序运行时的CPU环境信息。

# 进程的定义

* 进程时可并行执行的程序在一个数据集合上的运行过程，亦即进程实体的运行过程。进程实体由程序段、数据段、进程控制块3个部分构成。
* 进程是系统进行资源分配和调度的一个独立单元

进程的基础是2个虚拟化：虚拟处理器、虚拟内存

进程和程序的关系和区别

1. 结构特征方面：进程比程序多了进程控制块
2. 动态性：进程是有生命周期的，是动态执行的
3. 并发性：共存于内存，宏观同时运行
4. 独立性：进程之间调度、资源分配、运行时独立的
5. 异步性：推进相互独立、速度不可预知

原语：计算机进程的控制通常用原语完成。原语是由若干指令完成的程序段，用来实现某个特定功能，在执行过程中不可以被中断，否则会出现操作错误，造成系统混乱。有原子操作之义。

## <font size = 4>进程描述符及任务结构</font>

进程描述符或进程控制块

task_struct

内核把进程以双向循环链表的形式存放在任务队列中。链表的每一项是一个结构体类型，类型为task_struct，task_struct的实例就是进程描述符。进程描述符包含了一个具体进程的所有信息。

进程描述符包含了内核管理一个进程所需的所有信息，包含的数据能完整地描述一个正在执行的程序：打开的文件，进程的地址空间，挂起的信号，进程的状态等。

进程控制块功能的组成：

* 进程标志符，包括进程内部标识符、进程外部标识符、父/子标识符、用户标识符
* 处理机状态，由处理机的各种寄存器中的内容组成。
* 进程调度信息，包括进程状态、进程优先级、进程调度需要的其他信息、事件或阻塞原因。
* 进程控制信息，包括程序和数据地址，进程同步和通信机制，资源清单，链接指针。

进程上下文：当一个进程正在执行时，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容。当内核进行进程切换时，就需要保存当前进程的所有状态，以便再次执行该进程时，能够恢复到切换时的状态执行下去。

进程控制块的组织方式：链接表、索引表

## <font size = 4>进程的层次结构</font>

在Unix和Linux种，存在进程层次结构，共同组成一个进程组。在进程控制块种设置了家族关系表项，以表明父进程与所有子进程。

但是Windows进程是没有层次结构的概念的，所有的进程都具有相同的地位。一个进程创建另一个进程，会赋予一个句柄。这个句柄是可以传递的，获得了句柄的进程可以控制其他的进程。不再是层次关系，而是获得句柄与否，控制与被控制的关系。

## <font size = 4>进程的创建</font>

4种主要事件会触发进程的创建：

- 系统初始化
- 正在运行的程序执行了创建进程的系统调用
- 用户请求创建一个新进程
- 一个批处理作业的初始化

从技术角度而言，新进程都是由一个已存在的进程执行一个用于创建进程的系统调用而创建的。

Unix中分2步：fork和execve。fork进行创建一个与父进程相同的内存映像（仅PID、PPID和某些资源的通统计量如挂起的信号），execve修改其内存映像并运行。

Windows中1步完成：CreateProcess，既负责创建也负责装入运行，由参数设置新进程信息。

操作系统创建一个进程的过程如下：

* 申请空白的进程控制块，获得唯一的数字标识符
* 为新进程分配所需的资源，如内存，I/O，文件，CPU时间等，需要提前告知操作系统或父进程，例如需要分配的内存空间大小
* 初始化进程控制块
  + 初始化标识信息，填入本进程标识符和父进程标识符
  + 初始化处理机状态信息，例如程序计数器指向程序入口，栈指针指向栈顶
  + 初始化处理机控制信息，设置为就绪或静止就绪状态，一般优先级设置为最低
  + 待进程就绪队列能够接纳，便插入就绪队列

**写时拷贝**

> ​	传统的fork系统调用直接把所有的资源复制给新创建的进程，这种实现方式过于简单并且效率低下，因为拷贝的数据也许并不共享，更糟糕的是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的fork使用了写时拷贝。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时不是复制整个进程地址空间，而是让父进程与子进程共享一个拷贝。
>
> ​	只有在需要写入时，数据才会被复制，资源的复制只有在需要写入时才进行，之前都是只读方式共享。
>
> ​	fork的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。这种优化可以避免拷贝大量根本用不到的数据，因为一个进程一般创建后都会立刻运行一个可执行程序，数据也会被重写。

fork与vfork的区别：

+ fork子进程拷贝父进程的数据段、代码段；vfork子进程与父进程共享数据段
+ fork父子进程的执行次序不确定，由调度器确定；vfork保证子进程先运行，在调用exec或exit之后父进程才可能被调度运行
+ vfork如果子进程在调用exec或exit之前，依赖于父进程的进一步动作，则会导致死锁。

## <font size = 4>进程的终结</font>

进程的终结分为主动和被动2种：

主动型：进程的析构是自身引起的，即进程调用了exit系统调用，可能是显示的调用，也可能是隐式的某个程序的主函数返回（C编译器在main函数的返回点放置了exit代码）。

被动型：进程接受到它既不能处理也不能忽略的信号或异常时，也可能被动终结。

从进程终结的原因，可以分为3种：

**正常结束**，进程的任务已经完成，准备退出运行。

**异常结束**，进程在运行时发生了某种异常事件，使程序无法继续运行。常见的异常事件有：越界错，保护错，非法指令，特权指令错，运行超时，等待超时，算数运算错，I/O故障外界干预。

**外界干预**，进程应外界的请求而终止运行。这些干预有：操作员或操作系统干预（例如Ctrl+c），父进程请求，父进程终止。

进程终结的过程：

1. 进程调用exit系统调用后，执行内核函数do_exit，首先释放进程代码段、数据段占用的内存页面，关闭进程打开的文件，对进程使用的当前工作目录、根目录、和运行程序i节点进行同步操作；如果此进程由子进程，则让init进程作为其所有子进程的父进程；如果此进程是一个会话头进程且有控制终端，则释放控制终端，并向属于该会话的所有进程发送挂起信号SIGHUP。
2. 把进程状态置为僵死状态，并向其父进程发送SIGCHILD信号，通知父进程，该子进程已终止。
3. 最后，do_exit调用调度函数区执行其他进程。

更进一步的描述，系统中如果发生要求进程终止的事件后，操作系统便调用进程终止原语，终止该进程。

1. 根据被终止进程的标识符，从进程控制块队列中检索处该进程的进程控制块，从中读出该进程的状态；
2. 若被终止的进程处于执行状态，应立即终止该进程执行，该进程被终止后应置调度标志为真，用于指示该进程被终止，应重新进程调度；
3. 检查该进有没有子/孙进程，若有则将其所有子/孙进程终止；
4. 释放终止的进程所占有的资源，并将其归还他的父进程或系统；
5. 将被终止的进程从它的进程控制块队列中移除。

进程相关联的资源被释放掉之后，进程不再可运行，并处于僵死状态，此时进程存在的唯一目的时向其父进程提供信息，父进程在检索到信息后，或者通知内核此为无关信息后，进程所持有的剩余内存会被释放。

在执行子进程期间，父进程通常使用wait或waitpid函数等待其某个子进程终止。当等待的子进程被终止并处于僵死状态时，父进程就会把子进程运行所使用的时间累加到自己的进程中，最后释放已终止子进程任务数据结构所占用的内存页面，并置空子进程的任务数组中占用的指针项。

## <font size = 4>进程的基本状态及状态转换</font>

新状态、就绪 、运行、阻塞、终止

新状态----》就绪：接纳

就绪----》运行：调度

运行----》就绪：超时

运行----》阻塞：I/O请求或等待某事件

阻塞----》就绪：I/O完成或事件发生

运行----》终止：结束

**引入挂起状态的原因**

1. 终端用户的请求

   程序运行期间发现可以问题暂停进程

2. 父进程的请求

   考察、修改或协调子进程

3. 操作系统的需要

   运行过程中资源使用情况的检查和记账

4. 负载调节的需要

   负荷调节和保证实时系统正常运行

引起进程阻塞的事件：

1. 请求系统服务，但不能立即满足
2. 启动某种操作，且必须在该操作完成之后才可能继续执行，例如等到用户输入
3. 新数据尚未到达，相互合作的进程一方需首先获得另一方进程的数据才能继续
4. 无新工作可做，特定功能系统进程当完成任务且暂无任务

就绪挂起状态

阻塞挂起状态

新状态----》就绪挂起：接纳

运行----》就绪挂起：挂起

就绪----》就绪挂起：挂起

阻塞挂起----》就绪挂起：I/O完成或事件发生

就绪挂起----》就绪：激活

阻塞----》阻塞挂起：挂起

阻塞挂起----》阻塞：激活

Linux系统定义的5种进程状态：

+ TASK_RUNNNING：包含就绪和运行状态，由current变量来区分。
+ TASK_INTERRUPTIBLE：可中断的等待状态，进程正在等待某些事件，可以被信号唤醒。
+ TASK_UINTERRUPTIBLE：不可中断的等待状态，硬件资源无法满足，不能被信号唤醒。
+ TASK_ZOMBIE：僵死状态，进程被终止，所有资源被释放，但还保存着进程控制块信息。
+ TASK_STOPPED：暂停状态。

## <font size = 4>进程控制</font>

进程控制操作完成进程的各种状态之间的切换，由具有特定功能的原语来完成，包括：进程创建原语，进程终结原语，阻塞原语，唤醒原语，挂起原语，激活原语，改变进程优先级原语，等。

原语：完成某一个特定功能的一段程序，具有不可分割不可中断性。即原语的执行必须是连续的，在执行过程中不允许被中断。需要内核屏蔽中断，实现原子操作。

# 进程调度

调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。进程调度程序是在可运行态进程之间分配有限的处理器时间资源的内核子系统，是多任务操作系统的基础。调度程序完成的工作，简单说就是在一组处于可运行状态的进程中选择一个来执行。

## <font size = 4>多任务系统</font>

多任务系统分为2大类：非抢占式多任务、抢占式多任务

O(1)调度器：Uinx经典调度算法，主要基于静态时间片算法和针对每一个处理器的运行队列。但是该算法对于调度有响应时间敏感的程序（用户交互进程）有不足，对于大型服务器的工作负载很理想，但对有很多交互程序的桌面系统表现不佳，因其缺少交互进程。

完全公平调度算法：为了提高对交互程序的调度性能引入的新算法，将公平调度的概念引入了Linux调度程序，替代了O(1)调度算法。

## <font size=4> 调度策略</font>

调度策略决定的是调度程序在何时让什么进程运行，调度策略往往决定了整个系统的印象，还要负责优化使用处理器时间，至关重要。

**I/O消耗型和处理器消耗型的进程**

<font color='orange'>I/O消耗型进程：</font>进程大部分时间都用来提交I/O请求或着等待I/O请求。这类进程很长时间处于可运行状态（包括了阻塞状态），在运行状态时间很少。因为在等待更多的I/O请求时最后总会阻塞。典型的例子时GUI程序属于I/O密集型，有键盘输入，鼠标输入，网络I/O，磁盘读写等。

<font color='orange'>处理器消耗型进程：</font> 进程大部分时间都在执行代码，除非被抢占，否则都在不停运行，因为没有太多I/O需求，不会进入阻塞。对于这类进程，调度策略往往是尽量降低他们的调度频率，后果是延长了其运行时间。典型的例子是Matlab计算程序。

<font color='orange'>寻找平衡：</font> 调度策略需要在进程响应迅速和最大系统利用率（吞吐量）之间做平衡。目前而言，Unix和最新的Linux系统，都倾向于优先调度I/O消耗型进程。

## <font size=4>进程优先级</font>

调度算法中最基本的一类就是基于优先级的调度策略。基于优先级的调度策略是根据进程的价值和对处理器的时间需求进行的分级。通常，优先级高的进程先运行，低的后运行，相同级别的按轮转方式进行调度。

Linux操作系统采用了2种不同的优先级范围：nice值和实时优先级。

<font color='orange'>nice值</font>：静态优先级。继承于Uinx操作系统，在Linux里面nice值代表的是时间片的比例，范围是-20~19，默认值为0，值越大的进程比值小的进程优先级低，但是获得的处理器时间更少。<font color='red'>**NI**</font>

> 闲话：nice这个词怎么理解呢，nice在英语里面可以理解为人缘好的，人缘好的人都是懂得谦让，有礼貌的，所以可以理解为谦让值，谦让值越大则优先级越低。

<font color='orange'>实时优先级</font>：动态优先级。与nice值意义相反，越高的实时优先级数值意味着进程优先级越高。任何实时进程的优先级都高于普通进程，动态优先级在CFS调度器种不再使用。<font color='red'>**PR**</font>

##  <font size=4>时间片的概念</font>

时间片是一个数值，表明进程在被抢占前所能运行的时间。时间片过长，会导致系统交互的响应表现欠佳，时间片太短会明显增大进程切换带来的处理器损耗。同时，I/O消耗型进程不需要太多的处理器时间，但是要高的优先级，处理器消耗型进程需要较长的处理器时间，优先级不宜太高，这也是需要考虑的矛盾。

<font color='orange'>Linux的时间片机制</font>

Linux的CFS调度器没有直接将分配时间片到进程，而是将处理器的使用比例划分给进程，这种做法，进程获得的处理器时间和系统负载密切相关。同时，这个比例还受到nice值的影响。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程。

## <font size=4>详细讨论Linux调度算法</font>

Linux调度器以模块方式提供，方便不同类型的进程可以针对性地选择调度算法。

这种模块化结构称为调度器类，允许不同地可动态添加地调度算法并存，调度属于自己范畴地进程。每个调度器类有一个优先级，内核会按照优先级顺序遍历所有的调度类，有最好调度优先级的调度器（若该类有实例化的进程）类胜出。

CFS类（完全公平调度）：一个针对普通进程的调度类。

实时调度类